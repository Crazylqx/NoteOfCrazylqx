# A\*算法

A\*算法是一种启发式的最短路径算法。可以用于含有障碍物的图算法之中。

## Dijkstra算法

Dijkstra算法是很常用的最短路径算法，其要求图上两顶点之间距离非负。算法的思想是，从起始点A出发，依次检查**离A最近**的未检查顶点。
起初对其他点P，令`d(A, P)`为A与P的直接距离（不经过其他顶点），若A、P之间无路径则距离设为无穷大。
然后每次对A与未检查顶点P的距离`d(A, P)`排序，选取距离最小的点进行检查。
每当新检查一个顶点Q，将更新A与其余未检查顶点的距离（即若`d(A, Q) + d(Q, P) < d(A, P)`，则令`d(A, P) ← d(A, Q) + d(Q, P)`）。
这样保证检查顺序严格按照与A距离递增的关系进行。
如果检查到终点B，则意味着其余未检查顶点与A距离比A、B距离更远，也就不存在其他更短路径了。
这样，之前指定的从A到B的路径就是最短路径。算法本质是贪心的。
如果排序用斐波那契堆来实现，算法复杂度可以达到O(E+VlgV)。E、V为边数和顶点数。

## 最佳优先搜索（BFS）算法

Dijkstra算法很慢，他需要遍历所有比终点近的节点才能找到最短路径。
诚然，对于距离没什么规律的正权图来说Dijkstra可能是最好的算法了。
但是对于很多问题，我们可以给距离一个估计值（比如在寻路问题等）。
这个距离看作是一个启发式函数，设顶点N离终点B的距离估计是h(N)。
常用的启发式函数包括曼哈顿距离或者欧氏距离等。最佳优先搜索就是利用这样的启发式函数来工作。

BFS算法从起点A开始，依次寻找与A相邻且**离终点B最近**（按照h(N)估计）的顶点，并走出一条路径直到到达B。
这个算法的好处是速度很快，但其寻路过程过于短视，所以找到的往往是次优路径。
如果h(N)估计非常准确，算法是可以找到最短路径的。但是在很多寻路问题中，h(N)设想的最短路径往往存在障碍物。
这导致h(N)在障碍物（尤其是凹形障碍物）附近偏差很大，会导致寻路算法走到障碍物上撞墙才发现问题。

## A\*算法

A\*算法也是启发式算法，同样用到了最佳优先搜索算法中的函数h(N)。不同的是，它结合了Dijkstra的优点，且相当灵活，并且能用于各种情形。
在简单的情况中，它和BFS一样快；而在存在障碍物的情形下仍然可以找到最短路径。算法要求启发式函数**h(N)不大于N到终点B的实际最短距离**。

算法引入两个函数g(N)和h(N)，分别是N与起点A的实际距离和与终点B距离的估计。
这样经由N到达终点B的距离估计就是`f(N) = g(N) + h(N)`。算法会逐步遍历**f(N)最小**的顶点。
实际上，g(N)和h(N)这两项分别指导Dijkstra和BFS的遍历顺序。
但只有g(N)丧失了对终点方向的指导性，导致绕路；只有h(N)则会导致只能一直向前找到次优路径，
g(N)提供了一个回头重找的可能，它衡量了重新查找和一条道走到黑的代价差距。下面详细解释这个算法。

算法构造了两个集合，Open集和Closed集，分别代表已经发现但未检查的顶点和检查过的顶点。
首先，Open集中只包含起点A，Closed集为空。然后我们开始不断检查顶点。
如果Open非空，就从Open中找出f(N)最小的顶点N并检查。
如果N就是终点B则算法结束，g(B)即之前走过的路径长度就是最短路径长度，回溯历史可得最短路径；
如果N不是终点，则将N从open删除，放入closed集，然后遍历N的所有相邻顶点，
将其中不在Open和Closed集中的点（设为M）放入Open集，令M的父节点为N，g(M)为`g(N) + MN`。
这样不断从Open中找到f(N)最小的顶点检查，直到检查到终点B为止。

下面讨论算法的正确性。
假设A\*算法找到的路径并非最短路径，实际的最短路径为A-M1-M2-...B。
设Mi为不在Closed集中且i最小的最短路径上的点。
若Mi不存在，则设这个点是B（B显然不在Closed集中，在Open中取出B的时候就结束算法了）。
若如此，其路径上的上一个顶点（记为P）一定在Closed中（Mi一定不是最初的顶点，因为起点A在Closed中）。
这意味着，在P被放入Closed集时，Mi已经被放入Open集。而从Open集取出顶点的顺序是f函数升序取出的，
既然B被取出（然后算法才能终止），就有`f(Mi) >= f(B)`。注意到`f(Mi) = g(Mi) + h(Mi) <= g(Mi) + dist(Mi, B)`
其中`dist(Mi, B)`是Mi到B的最短距离，`f(B) = g(B)`为A\*找到的路径长度，所以`g(Mi) + dist(Mi, B) >= g(B)`，
即经由Mi的路径长度不可能短于A\*找到的路径，与假设产生矛盾。所以A\*算法找到的路径一定是最短路径。